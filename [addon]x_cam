bl_info = {
    "name": "x_cam",
    "author": "å¾è¡Œ + ä¹¦æ˜Ÿ",
    "version": (1, 4),
    "blender": (3, 0, 0),
    "location": "3D View > Sidebar > XCam",
    "description": "é›†ä¸­æ§åˆ¶æ¸²æŸ“ç›¸å…³å‚æ•°ä¸ç›¸æœºåŒæ­¥",
    "category": "3D View",
}

import bpy

# ===============================
# ğŸ§­ Operator: å°† Scene Camera è®¾ç½®ä¸º View Local Camera
# ===============================
class XCAM_OT_SetLocalToScene(bpy.types.Operator):
    """å°†å½“å‰ Scene Camera è®¾ç½®ä¸º View Local Camera"""
    bl_idname = "xcam.local_to_scene"
    bl_label = "xcam.local_to_scene"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        scene = context.scene
        cam = scene.camera
        if not cam:
            self.report({'WARNING'}, "å½“å‰åœºæ™¯æ²¡æœ‰è®¾ç½®ç›¸æœºï¼")
            return {'CANCELLED'}

        area = context.area
        if area and area.type == 'VIEW_3D':
            space = area.spaces.active
            if space and space.type == 'VIEW_3D':
                space.camera = cam
                self.report({'INFO'}, f"å·²å°†æœ¬åœ°ç›¸æœºè®¾ç½®ä¸ºåœºæ™¯ç›¸æœºï¼š{cam.name}")
        return {'FINISHED'}


# ===============================
# ğŸ§­ Operator: å°† View Local Camera è®¾ç½®ä¸º Scene Camera
# ===============================
class XCAM_OT_SetSceneToLocal(bpy.types.Operator):
    """å°†å½“å‰ View Local Camera è®¾ç½®ä¸º Scene Camera"""
    bl_idname = "xcam.scene_to_local"
    bl_label = "xcam.scene_to_local"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        scene = context.scene
        area = context.area

        if area and area.type == 'VIEW_3D':
            space = area.spaces.active
            if space and space.type == 'VIEW_3D' and space.camera:
                scene.camera = space.camera
                self.report({'INFO'}, f"å·²å°†åœºæ™¯ç›¸æœºè®¾ç½®ä¸ºï¼š{space.camera.name}")
            else:
                self.report({'WARNING'}, "å½“å‰è§†å›¾æœªè®¾ç½® Local Camera")
        return {'FINISHED'}


# ===============================
# ğŸ¥ Operator: åˆ‡æ¢ç›¸æœºè§†å›¾ï¼ˆè¿›å…¥/é€€å‡ºç›¸æœºï¼‰
# ===============================
class XCAM_OT_ToggleCameraView(bpy.types.Operator):
    """è¿›å…¥æˆ–é€€å‡ºç›¸æœºè§†å›¾"""
    bl_idname = "xcam.toggle_camera_view"
    bl_label = "è¿›å…¥ç›¸æœº"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        area = context.area
        if area and area.type == 'VIEW_3D':
            space = area.spaces.active
            if space.region_3d.view_perspective == 'CAMERA':
                space.region_3d.view_perspective = 'PERSP'
                self.report({'INFO'}, "é€€å‡ºç›¸æœºè§†å›¾")
            else:
                space.region_3d.view_perspective = 'CAMERA'
                self.report({'INFO'}, "è¿›å…¥ç›¸æœºè§†å›¾")
        return {'FINISHED'}


# ===============================
# ğŸ”— Operator: ç»‘å®š / è§£ç»‘ç›¸æœºä¸è§†å£
# ===============================
class XCAM_OT_ToggleCameraLock(bpy.types.Operator):
    """ç»‘å®šæˆ–è§£ç»‘ç›¸æœºå’Œè§†å£"""
    bl_idname = "xcam.toggle_camera_lock"
    bl_label = "ç»‘å®šç›¸æœºå’Œè§†å£"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        space = context.space_data
        if space.type == 'VIEW_3D':
            space.lock_camera = not space.lock_camera
            if space.lock_camera:
                self.report({'INFO'}, "å·²ç»‘å®šç›¸æœºå’Œè§†å£ï¼ˆå¯åœ¨ç›¸æœºä¸­å¯¼èˆªï¼‰")
            else:
                self.report({'INFO'}, "å·²è§£ç»‘ç›¸æœºå’Œè§†å£")
        return {'FINISHED'}


# ===============================
# ğŸ–¼ï¸ Operator: æ¸²æŸ“å½“å‰å¸§
# ===============================
class XCAM_OT_RenderCurrentFrame(bpy.types.Operator):
    """æ¸²æŸ“å½“å‰å¸§"""
    bl_idname = "xcam.render_current_frame"
    bl_label = "æ¸²æŸ“å½“å‰å¸§"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        bpy.ops.render.render('INVOKE_DEFAULT')
        return {'FINISHED'}


# ===============================
# ğŸ¯ Operator: é€‰ä¸­ç›¸æœºï¼ˆå°æ–¹å—æŒ‰é’®ï¼‰
# ===============================
class XCAM_OT_SelectCamera(bpy.types.Operator):
    """é€‰ä¸­æŒ‡å®šç›¸æœº"""
    bl_idname = "xcam.select_camera"
    bl_label = "Select Camera"
    bl_options = {'REGISTER', 'UNDO'}

    camera_name: bpy.props.StringProperty(name="Camera Name")

    def execute(self, context):
        cam = bpy.data.objects.get(self.camera_name)
        if not cam:
            self.report({'WARNING'}, f"æœªæ‰¾åˆ°å¯¹è±¡ï¼š{self.camera_name}")
            return {'CANCELLED'}
        if cam.type != 'CAMERA':
            self.report({'WARNING'}, f"å¯¹è±¡ä¸æ˜¯ç›¸æœºï¼š{cam.name}")
            return {'CANCELLED'}

        # åˆ‡åˆ°å¯¹è±¡æ¨¡å¼ä»¥é¿å…æŸäº›æ¨¡å¼ä¸‹æ— æ³•åˆ‡æ¢æ¿€æ´»å¯¹è±¡
        if context.mode != 'OBJECT':
            try:
                bpy.ops.object.mode_set(mode='OBJECT')
            except Exception:
                pass

        # é€‰ä¸­å¹¶è®¾ä¸ºæ¿€æ´»
        view_layer = context.view_layer
        for obj in view_layer.objects:
            obj.select_set(False)
        cam.select_set(True)
        view_layer.objects.active = cam

        self.report({'INFO'}, f"å·²é€‰ä¸­ç›¸æœºï¼š{cam.name}")
        return {'FINISHED'}


def draw_separator(layout, scale=0.1):
    box = layout.box()
    row = box.row()
    row.scale_y = scale
    row.label(text="")

# ===============================
# ğŸ›ï¸ Panel: XCam æ§åˆ¶é¢æ¿
# ===============================
class XCAM_PT_Panel(bpy.types.Panel):
    bl_label = "XCam Control"
    bl_idname = "VIEW3D_PT_xcam"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "XCam"

    def draw(self, context):
        main_layout = self.layout
        scene = context.scene
        render = scene.render
        ev = scene.view_settings
        view = context.space_data

        #
        # ---- æ¸²æŸ“å‚æ•° ----
        #
        layout = main_layout.box()
        layout.label(text="â”€â”€ æ¸²æŸ“å‚æ•° â”€â”€")

        # æ¸²æŸ“å™¨
        row = layout.row(align=True)
        split = row.split(factor=0.25)
        split.label(text="æ¸²æŸ“å™¨")
        split.prop(scene.render, "engine", text="")

        # æ›å…‰
        row = layout.row(align=True)
        split = row.split(factor=0.25)
        split.label(text="æ›å…‰")
        split.prop(ev, "exposure", text="")

        # åˆ†è¾¨ç‡
        layout.label(text="åˆ†è¾¨ç‡")
        col = layout.column(align=True)
        row = col.row(align=True)
        row.prop(render, "resolution_x", text="X")
        row.prop(render, "resolution_y", text="Y")
        col.prop(render, "resolution_percentage", text="Scale")

        #
        # ---- ç›¸æœºæ§åˆ¶ ----
        #
        layout = main_layout.box()
        layout.label(text="â”€â”€ ç›¸æœºæ§åˆ¶ â”€â”€")
        
                # è¿›å…¥/é€€å‡ºç›¸æœºè§†å›¾ + ç»‘å®š/è§£ç»‘
        row = layout.row(align=True)
        space = context.space_data

        # ç›¸æœºè§†å›¾åˆ‡æ¢æŒ‰é’®
        if space.region_3d.view_perspective == 'CAMERA':
            row.operator(
                "xcam.toggle_camera_view",
                text="é€€å‡ºç›¸æœº",
                icon='HIDE_OFF',  # ä»£è¡¨æ˜¾ç¤º/é€€å‡ºçŠ¶æ€
                depress=True
            )
        else:
            row.operator(
                "xcam.toggle_camera_view",
                text="è¿›å…¥ç›¸æœº",
                icon='CAMERA_DATA'  # ä»£è¡¨è¿›å…¥ç›¸æœº
            )

        # ç»‘å®š / è§£ç»‘ ç›¸æœºä¸è§†å£
        is_locked = getattr(space, "lock_camera", False)
        if is_locked:
            row.operator(
                "xcam.toggle_camera_lock",
                text="è§£ç»‘ç›¸æœºå’Œè§†å£",
                icon='LOCKED',  # é”å®šçŠ¶æ€å›¾æ ‡
                depress=True
            )
        else:
            row.operator(
                "xcam.toggle_camera_lock",
                text="ç»‘å®šç›¸æœºå’Œè§†å£",
                icon='UNLOCKED'  # æœªé”å®šçŠ¶æ€å›¾æ ‡
            )


        # è§†å£ç›¸æœºï¼ˆLocal Cameraï¼‰
        row = layout.row(align=True)
        split = row.split(factor=0.25)
        split.label(text="è§†å£ç›¸æœº")
        row_cam = split.row(align=True)
        if view:
            row_cam.prop(view, "camera", text="")
            if view.camera:
                row_cam.operator("xcam.select_camera", text="", icon='RESTRICT_SELECT_OFF').camera_name = view.camera.name
        else:
            split.label(text="(None)")
            
        # ä¸Šä¸‹åŒæ­¥æŒ‰é’®
        row = layout.row(align=True)
        row.operator("xcam.local_to_scene", text="â†‘")
        row.operator("xcam.scene_to_local", text="â†“")
        
        # åœºæ™¯ç›¸æœº
        row = layout.row(align=True)
        split = row.split(factor=0.25)
        split.label(text="åœºæ™¯ç›¸æœº")
        row_cam = split.row(align=True)
        row_cam.prop(scene, "camera", text="")
        if scene.camera:
            row_cam.operator("xcam.select_camera", text="", icon='RESTRICT_SELECT_OFF').camera_name = scene.camera.name
        
        #
        # æ¸²æŸ“å½“å‰å¸§
        #
        
        layout = main_layout
        layout.separator()

        scene_camera_name = ""
        if scene.camera:
            scene_camera_name = scene.camera.name

        # æ£€æŸ¥è§†å£ç›¸æœºå’Œåœºæ™¯ç›¸æœºæ˜¯å¦ä¸åŒ
        view_cam = view.camera if view else None
        scene_cam = scene.camera
        cameras_differ = view_cam and scene_cam and (view_cam != scene_cam)

        if cameras_differ:
            # æç¤ºï¼šå½“å‰è§†å£ç›¸æœºå’Œåœºæ™¯ç›¸æœºä¸åŒ
            warn_row = layout.row()
            warn_row.alert = True
            warn_row.label(text="æ³¨æ„ï¼šå½“å‰è§†å£ç›¸æœºå’Œåœºæ™¯ç›¸æœºä¸åŒ", icon='ERROR')

        # æ¸²æŸ“æŒ‰é’®
        row = layout.row()
        if cameras_differ:
            row.alert = True  # çº¢è‰²æŒ‰é’®
        row.operator("xcam.render_current_frame", text=f"æ¸²æŸ“ {scene_camera_name}", icon='RENDER_STILL')


# ===============================
# ğŸ”§ Register
# ===============================
classes = (
    XCAM_OT_SetLocalToScene,
    XCAM_OT_SetSceneToLocal,
    XCAM_OT_ToggleCameraView,
    XCAM_OT_ToggleCameraLock,
    XCAM_OT_RenderCurrentFrame,
    XCAM_OT_SelectCamera,   # æ–°å¢çš„é€‰ä¸­ç›¸æœºæŒ‰é’®
    XCAM_PT_Panel,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)

if __name__ == "__main__":
    register()
