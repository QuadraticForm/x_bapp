bl_info = {
    "name": "bapp",
    "author": "å¾è¡Œ + ä¹¦æ˜Ÿ",
    "version": (1, 1),
    "blender": (3, 0, 0),
    "location": "3D View > Sidebar > Bapp",
    "description": "Blender App Manager - save/load text blocks to a folder",
    "category": "3D View",
}

import bpy
import os
import traceback
import __main__


# =========================================================
# ğŸ§© ä¸»è¦é€»è¾‘å‡½æ•°
# =========================================================

def get_bapp_dir(scene):
    """è·å–å½“å‰ Bapp æ ¹ç›®å½•"""
    return scene.bapp_root_dir if scene.bapp_root_dir else ""


def save_bapp_texts(context):
    """ä¿å­˜æ‰€æœ‰å¸¦æ–¹æ‹¬å·çš„ Text Block åˆ° bapp æ ¹ç›®å½•"""
    scene = context.scene
    root = get_bapp_dir(scene)
    if not root or not os.path.isdir(root):
        return f"âš ï¸ Invalid Bapp directory: {root}"

    saved = []
    for txt in bpy.data.texts:
        if "[" in txt.name and "]" in txt.name:
            path = os.path.join(root, txt.name)
            with open(path, "w", encoding="utf-8") as f:
                f.write(txt.as_string())
            saved.append(txt.name)

    return f"âœ… Saved {len(saved)} text blocks to: {root}" if saved else "âš ï¸ No [bracketed] texts found."


def load_bapp_texts(context):
    """ä» bapp æ ¹ç›®å½•åŠ è½½æ‰€æœ‰æ–‡ä»¶åˆ° Text Editor"""
    scene = context.scene
    root = get_bapp_dir(scene)
    if not root or not os.path.isdir(root):
        return f"âš ï¸ Invalid Bapp directory: {root}"

    loaded = []
    for name in os.listdir(root):
        path = os.path.join(root, name)
        if os.path.isfile(path):
            if name in bpy.data.texts:
                txt = bpy.data.texts[name]
                txt.clear()
            else:
                txt = bpy.data.texts.new(name)
            with open(path, "r", encoding="utf-8") as f:
                txt.from_string(f.read())
            loaded.append(name)

    return f"âœ… Loaded {len(loaded)} text files from: {root}" if loaded else "âš ï¸ No files found in bapp directory."


# =========================================================
# ğŸ§  Text Editor ä¸Šä¸‹æ–‡æ‰§è¡Œé€»è¾‘
# =========================================================

def _find_text_editor_context():
    """æŸ¥æ‰¾ Text Editor ä¸Šä¸‹æ–‡"""
    for window in bpy.context.window_manager.windows:
        for area in window.screen.areas:
            if area.type == 'TEXT_EDITOR':
                ctx = {
                    "window": window,
                    "screen": window.screen,
                    "area": area,
                    "region": area.regions[-1],
                }
                return ctx
    return None


def _run_install_in_text_context():
    """çœŸæ­£æ‰§è¡Œ [bapp]installï¼ˆå»¶è¿Ÿæ‰§è¡Œå‡½æ•°ï¼‰"""
    install_block = bpy.data.texts.get("[bapp]install")
    if not install_block:
        print("âš ï¸ [bapp]install not found.")
        return None

    code = install_block.as_string()
    ctx = _find_text_editor_context()

    try:
        if ctx:
            print("ğŸŸ¦ Running [bapp]install inside TEXT_EDITOR context")
        else:
            print("âš ï¸ No TEXT_EDITOR found, running in current context")

        exec(compile(code, "[bapp]install", "exec"), __main__.__dict__)
        print("âœ… [bapp]install executed successfully.")
    except Exception:
        traceback.print_exc()

    # ä¸é‡å¤æ‰§è¡Œ
    return None


def run_bapp_install(context):
    """è°ƒåº¦ [bapp]install å»¶è¿Ÿæ‰§è¡Œ"""
    bpy.app.timers.register(_run_install_in_text_context, first_interval=0.1)
    return "â³ [bapp]install scheduled to run safely."


# =========================================================
# ğŸ§­ Operators
# =========================================================

class BAPP_OT_Save(bpy.types.Operator):
    bl_idname = "bapp.save"
    bl_label = "Save"
    bl_description = "Save all [bracketed] text blocks to bapp root directory"

    def execute(self, context):
        msg = save_bapp_texts(context)
        self.report({'INFO'}, msg)
        print(msg)
        return {'FINISHED'}


class BAPP_OT_Load(bpy.types.Operator):
    bl_idname = "bapp.load"
    bl_label = "Load"
    bl_description = "Load all files from bapp root directory into Blender text blocks"

    def execute(self, context):
        msg = load_bapp_texts(context)
        self.report({'INFO'}, msg)
        print(msg)
        return {'FINISHED'}


class BAPP_OT_Install(bpy.types.Operator):
    bl_idname = "bapp.install"
    bl_label = "Run [bapp]install"
    bl_description = "Execute the [bapp]install text block"

    def execute(self, context):
        msg = run_bapp_install(context)
        self.report({'INFO'}, msg)
        print(msg)
        return {'FINISHED'}


# =========================================================
# ğŸ›ï¸ UI Panel
# =========================================================

class BAPP_PT_MainPanel(bpy.types.Panel):
    bl_label = "Bapp"
    bl_idname = "VIEW3D_PT_bapp"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "Bapp"

    def draw(self, context):
        layout = self.layout
        scene = context.scene

        layout.label(text="Bapp Root Directory:")
        layout.prop(scene, "bapp_root_dir", text="")

        layout.separator()
        row = layout.row(align=True)
        row.operator("bapp.save", icon='FILE_TICK')
        row.operator("bapp.load", icon='FILE_REFRESH')

        layout.separator()
        layout.operator("bapp.install", icon='PLAY')


# =========================================================
# âš™ï¸ æ³¨å†Œ
# =========================================================

classes = (
    BAPP_OT_Save,
    BAPP_OT_Load,
    BAPP_OT_Install,
    BAPP_PT_MainPanel,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.bapp_root_dir = bpy.props.StringProperty(
        name="Bapp Root Dir",
        subtype='DIR_PATH',
        description="Directory where Bapp saves/loads its text blocks"
    )

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.bapp_root_dir

if __name__ == "__main__":
    register()
